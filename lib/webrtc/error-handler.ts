/**\n * WebRTC Error Handler\n * \n * Provides comprehensive error handling, recovery mechanisms, and user-friendly\n * error messages for WebRTC operations.\n */\n\nimport { SignalingErrorCode } from './types.ts';\n\n/**\n * Error Recovery Strategy\n */\nexport interface ErrorRecoveryStrategy {\n  maxRetries: number;\n  baseDelay: number; // Base delay in ms\n  maxDelay: number; // Maximum delay in ms\n  backoffMultiplier: number;\n  enableGracefulDegradation: boolean;\n}\n\n/**\n * Error Context Information\n */\nexport interface ErrorContext {\n  operation: string;\n  participantId?: string;\n  roomId?: string;\n  timestamp: Date;\n  userAgent: string;\n  connectionState?: RTCPeerConnectionState;\n  iceConnectionState?: RTCIceConnectionState;\n  additionalData?: Record<string, any>;\n}\n\n/**\n * Recovery Action\n */\nexport interface RecoveryAction {\n  type: 'retry' | 'fallback' | 'notify' | 'redirect';\n  message: string;\n  action?: () => Promise<void>;\n  delay?: number;\n}\n\n/**\n * Error Handler Events\n */\nexport interface ErrorHandlerEvents {\n  'error-occurred': (error: WebRTCError, context: ErrorContext) => void;\n  'recovery-attempted': (strategy: RecoveryAction, attempt: number) => void;\n  'recovery-succeeded': (strategy: RecoveryAction) => void;\n  'recovery-failed': (error: WebRTCError, maxRetriesReached: boolean) => void;\n  'graceful-degradation': (fallbackMode: string) => void;\n}\n\n/**\n * Enhanced WebRTC Error Class\n */\nexport class WebRTCError extends Error {\n  public readonly code: SignalingErrorCode;\n  public readonly context: ErrorContext;\n  public readonly isRecoverable: boolean;\n  public readonly userMessage: string;\n  public readonly technicalDetails: string;\n  public readonly suggestedActions: string[];\n\n  constructor(\n    message: string,\n    code: SignalingErrorCode,\n    context: ErrorContext,\n    options: {\n      isRecoverable?: boolean;\n      userMessage?: string;\n      technicalDetails?: string;\n      suggestedActions?: string[];\n    } = {}\n  ) {\n    super(message);\n    this.name = 'WebRTCError';\n    this.code = code;\n    this.context = context;\n    this.isRecoverable = options.isRecoverable ?? true;\n    this.userMessage = options.userMessage ?? this.getDefaultUserMessage(code);\n    this.technicalDetails = options.technicalDetails ?? message;\n    this.suggestedActions = options.suggestedActions ?? this.getDefaultSuggestedActions(code);\n  }\n\n  private getDefaultUserMessage(code: SignalingErrorCode): string {\n    switch (code) {\n      case SignalingErrorCode.CONNECTION_FAILED:\n        return 'Unable to connect to the room. Please check your internet connection and try again.';\n      case SignalingErrorCode.MEDIA_PERMISSION_DENIED:\n        return 'Camera or microphone access was denied. Please enable permissions and refresh the page.';\n      case SignalingErrorCode.ROOM_NOT_FOUND:\n        return 'The room you\\'re trying to join doesn\\'t exist or has been closed.';\n      case SignalingErrorCode.PARTICIPANT_LIMIT_EXCEEDED:\n        return 'This room is full. Please try again later or contact the host.';\n      case SignalingErrorCode.AUTHENTICATION_FAILED:\n        return 'Authentication failed. Please check your invitation link and try again.';\n      case SignalingErrorCode.SIGNALING_ERROR:\n        return 'Communication error occurred. Attempting to reconnect...';\n      case SignalingErrorCode.PEER_CONNECTION_FAILED:\n        return 'Connection to other participants failed. Trying to reconnect...';\n      case SignalingErrorCode.RECORDING_FAILED:\n        return 'Recording failed. Your audio may not have been saved.';\n      case SignalingErrorCode.UPLOAD_FAILED:\n        return 'Upload failed. Your recording is saved locally and will retry automatically.';\n      default:\n        return 'An unexpected error occurred. Please try refreshing the page.';\n    }\n  }\n\n  private getDefaultSuggestedActions(code: SignalingErrorCode): string[] {\n    switch (code) {\n      case SignalingErrorCode.CONNECTION_FAILED:\n        return [\n          'Check your internet connection',\n          'Try refreshing the page',\n          'Disable VPN if active',\n          'Contact support if the problem persists'\n        ];\n      case SignalingErrorCode.MEDIA_PERMISSION_DENIED:\n        return [\n          'Click the camera/microphone icon in your browser\\'s address bar',\n          'Select \"Allow\" for camera and microphone access',\n          'Refresh the page after granting permissions',\n          'Check your browser settings if the option is not available'\n        ];\n      case SignalingErrorCode.ROOM_NOT_FOUND:\n        return [\n          'Verify the room link is correct',\n          'Check if the room is still active',\n          'Contact the host for a new invitation'\n        ];\n      case SignalingErrorCode.PARTICIPANT_LIMIT_EXCEEDED:\n        return [\n          'Wait for someone to leave the room',\n          'Contact the host to increase the participant limit',\n          'Try joining again in a few minutes'\n        ];\n      case SignalingErrorCode.AUTHENTICATION_FAILED:\n        return [\n          'Use the original invitation link',\n          'Check if your invitation has expired',\n          'Request a new invitation from the host'\n        ];\n      default:\n        return [\n          'Refresh the page',\n          'Check your internet connection',\n          'Try again in a few moments',\n          'Contact support if the issue continues'\n        ];\n    }\n  }\n}\n\n/**\n * WebRTC Error Handler Class\n */\nexport class WebRTCErrorHandler {\n  private strategy: ErrorRecoveryStrategy;\n  private eventListeners = new Map<keyof ErrorHandlerEvents, Function[]>();\n  private retryAttempts = new Map<string, number>();\n  private lastErrors = new Map<string, WebRTCError>();\n\n  constructor(strategy?: Partial<ErrorRecoveryStrategy>) {\n    this.strategy = {\n      maxRetries: 3,\n      baseDelay: 1000,\n      maxDelay: 30000,\n      backoffMultiplier: 2,\n      enableGracefulDegradation: true,\n      ...strategy\n    };\n  }\n\n  /**\n   * Handle a WebRTC error with automatic recovery\n   */\n  async handleError(\n    error: Error | WebRTCError,\n    context: Partial<ErrorContext>,\n    recoveryCallback?: () => Promise<void>\n  ): Promise<RecoveryAction | null> {\n    const webrtcError = this.normalizeError(error, context);\n    const errorKey = this.getErrorKey(webrtcError);\n    \n    // Track error occurrence\n    this.lastErrors.set(errorKey, webrtcError);\n    this.emit('error-occurred', webrtcError, webrtcError.context);\n    \n    console.error('WebRTC Error:', webrtcError.technicalDetails, webrtcError.context);\n\n    // Determine recovery strategy\n    const recoveryAction = this.determineRecoveryAction(webrtcError);\n    \n    if (recoveryAction && webrtcError.isRecoverable) {\n      return await this.executeRecovery(webrtcError, recoveryAction, recoveryCallback);\n    }\n\n    return recoveryAction;\n  }\n\n  /**\n   * Handle connection-specific errors\n   */\n  async handleConnectionError(\n    participantId: string,\n    connectionState: RTCPeerConnectionState,\n    iceConnectionState: RTCIceConnectionState,\n    recoveryCallback?: () => Promise<void>\n  ): Promise<RecoveryAction | null> {\n    const context: ErrorContext = {\n      operation: 'peer-connection',\n      participantId,\n      timestamp: new Date(),\n      userAgent: navigator.userAgent,\n      connectionState,\n      iceConnectionState\n    };\n\n    let errorCode: SignalingErrorCode;\n    let message: string;\n\n    if (connectionState === 'failed') {\n      errorCode = SignalingErrorCode.PEER_CONNECTION_FAILED;\n      message = `Peer connection failed for participant ${participantId}`;\n    } else if (iceConnectionState === 'failed') {\n      errorCode = SignalingErrorCode.CONNECTION_FAILED;\n      message = `ICE connection failed for participant ${participantId}`;\n    } else {\n      errorCode = SignalingErrorCode.CONNECTION_FAILED;\n      message = `Connection issue for participant ${participantId}: ${connectionState}/${iceConnectionState}`;\n    }\n\n    const error = new WebRTCError(message, errorCode, context);\n    return await this.handleError(error, context, recoveryCallback);\n  }\n\n  /**\n   * Handle media permission errors\n   */\n  handleMediaPermissionError(mediaType: 'audio' | 'video' | 'screen'): RecoveryAction {\n    const context: ErrorContext = {\n      operation: 'media-permission',\n      timestamp: new Date(),\n      userAgent: navigator.userAgent,\n      additionalData: { mediaType }\n    };\n\n    const error = new WebRTCError(\n      `${mediaType} permission denied`,\n      SignalingErrorCode.MEDIA_PERMISSION_DENIED,\n      context,\n      {\n        isRecoverable: false,\n        userMessage: `${mediaType.charAt(0).toUpperCase() + mediaType.slice(1)} access was denied. Please enable permissions and refresh the page.`,\n        suggestedActions: [\n          `Enable ${mediaType} permissions in your browser`,\n          'Refresh the page after granting permissions',\n          'Check your browser settings',\n          mediaType === 'video' ? 'Continue with audio-only mode' : 'Contact support if needed'\n        ]\n      }\n    );\n\n    this.emit('error-occurred', error, context);\n\n    // Offer graceful degradation for video permission denial\n    if (mediaType === 'video' && this.strategy.enableGracefulDegradation) {\n      this.emit('graceful-degradation', 'audio-only');\n      return {\n        type: 'fallback',\n        message: 'Continuing in audio-only mode',\n        action: async () => {\n          console.log('Falling back to audio-only mode');\n        }\n      };\n    }\n\n    return {\n      type: 'notify',\n      message: error.userMessage\n    };\n  }\n\n  /**\n   * Handle recording errors with local backup\n   */\n  async handleRecordingError(\n    error: Error,\n    context: Partial<ErrorContext>,\n    localBackupCallback?: () => Promise<void>\n  ): Promise<RecoveryAction> {\n    const webrtcError = new WebRTCError(\n      error.message,\n      SignalingErrorCode.RECORDING_FAILED,\n      {\n        operation: 'recording',\n        timestamp: new Date(),\n        userAgent: navigator.userAgent,\n        ...context\n      },\n      {\n        isRecoverable: true,\n        userMessage: 'Recording failed. Attempting to save locally...',\n        suggestedActions: [\n          'Recording will be saved locally',\n          'Upload will be retried automatically',\n          'Check your storage space',\n          'Contact support if the issue persists'\n        ]\n      }\n    );\n\n    this.emit('error-occurred', webrtcError, webrtcError.context);\n\n    // Attempt local backup\n    if (localBackupCallback) {\n      try {\n        await localBackupCallback();\n        return {\n          type: 'fallback',\n          message: 'Recording saved locally. Upload will retry automatically.'\n        };\n      } catch (backupError) {\n        console.error('Local backup failed:', backupError);\n      }\n    }\n\n    return {\n      type: 'notify',\n      message: webrtcError.userMessage\n    };\n  }\n\n  /**\n   * Get user-friendly error message\n   */\n  getUserFriendlyMessage(error: Error | WebRTCError): string {\n    if (error instanceof WebRTCError) {\n      return error.userMessage;\n    }\n    \n    // Handle common browser errors\n    if (error.name === 'NotAllowedError') {\n      return 'Permission denied. Please enable camera and microphone access.';\n    }\n    if (error.name === 'NotFoundError') {\n      return 'Camera or microphone not found. Please check your devices.';\n    }\n    if (error.name === 'NotReadableError') {\n      return 'Camera or microphone is already in use by another application.';\n    }\n    if (error.name === 'OverconstrainedError') {\n      return 'Camera or microphone settings are not supported.';\n    }\n    \n    return 'An unexpected error occurred. Please try again.';\n  }\n\n  /**\n   * Reset retry attempts for a specific error\n   */\n  resetRetryAttempts(errorKey?: string): void {\n    if (errorKey) {\n      this.retryAttempts.delete(errorKey);\n    } else {\n      this.retryAttempts.clear();\n    }\n  }\n\n  /**\n   * Update recovery strategy\n   */\n  updateStrategy(newStrategy: Partial<ErrorRecoveryStrategy>): void {\n    this.strategy = { ...this.strategy, ...newStrategy };\n  }\n\n  /**\n   * Get error statistics\n   */\n  getErrorStats(): {\n    totalErrors: number;\n    errorsByType: Record<string, number>;\n    recentErrors: WebRTCError[];\n  } {\n    const errors = Array.from(this.lastErrors.values());\n    const errorsByType: Record<string, number> = {};\n    \n    errors.forEach(error => {\n      const type = error.code.toString();\n      errorsByType[type] = (errorsByType[type] || 0) + 1;\n    });\n\n    return {\n      totalErrors: errors.length,\n      errorsByType,\n      recentErrors: errors.slice(-10) // Last 10 errors\n    };\n  }\n\n  /**\n   * Add event listener\n   */\n  on<K extends keyof ErrorHandlerEvents>(event: K, listener: ErrorHandlerEvents[K]): void {\n    if (!this.eventListeners.has(event)) {\n      this.eventListeners.set(event, []);\n    }\n    this.eventListeners.get(event)!.push(listener);\n  }\n\n  /**\n   * Remove event listener\n   */\n  off<K extends keyof ErrorHandlerEvents>(event: K, listener: ErrorHandlerEvents[K]): void {\n    const listeners = this.eventListeners.get(event);\n    if (listeners) {\n      const index = listeners.indexOf(listener);\n      if (index > -1) {\n        listeners.splice(index, 1);\n      }\n    }\n  }\n\n  /**\n   * Emit event\n   */\n  private emit<K extends keyof ErrorHandlerEvents>(event: K, ...args: Parameters<ErrorHandlerEvents[K]>): void {\n    const listeners = this.eventListeners.get(event);\n    if (listeners) {\n      listeners.forEach(listener => {\n        try {\n          (listener as any)(...args);\n        } catch (error) {\n          console.error(`Error in error handler event listener for ${event}:`, error);\n        }\n      });\n    }\n  }\n\n  /**\n   * Normalize error to WebRTCError\n   */\n  private normalizeError(error: Error | WebRTCError, context: Partial<ErrorContext>): WebRTCError {\n    if (error instanceof WebRTCError) {\n      return error;\n    }\n\n    const fullContext: ErrorContext = {\n      operation: 'unknown',\n      timestamp: new Date(),\n      userAgent: navigator.userAgent,\n      ...context\n    };\n\n    // Determine error code based on error type\n    let errorCode = SignalingErrorCode.UNKNOWN_ERROR;\n    if (error.name === 'NotAllowedError') {\n      errorCode = SignalingErrorCode.MEDIA_PERMISSION_DENIED;\n    } else if (error.message.includes('connection')) {\n      errorCode = SignalingErrorCode.CONNECTION_FAILED;\n    } else if (error.message.includes('signaling')) {\n      errorCode = SignalingErrorCode.SIGNALING_ERROR;\n    }\n\n    return new WebRTCError(error.message, errorCode, fullContext);\n  }\n\n  /**\n   * Generate error key for tracking\n   */\n  private getErrorKey(error: WebRTCError): string {\n    return `${error.code}-${error.context.operation}-${error.context.participantId || 'global'}`;\n  }\n\n  /**\n   * Determine recovery action based on error\n   */\n  private determineRecoveryAction(error: WebRTCError): RecoveryAction {\n    const errorKey = this.getErrorKey(error);\n    const attempts = this.retryAttempts.get(errorKey) || 0;\n\n    if (attempts >= this.strategy.maxRetries) {\n      return {\n        type: 'notify',\n        message: `${error.userMessage} Maximum retry attempts reached.`\n      };\n    }\n\n    switch (error.code) {\n      case SignalingErrorCode.CONNECTION_FAILED:\n      case SignalingErrorCode.SIGNALING_ERROR:\n      case SignalingErrorCode.PEER_CONNECTION_FAILED:\n        return {\n          type: 'retry',\n          message: 'Attempting to reconnect...',\n          delay: this.calculateDelay(attempts)\n        };\n      \n      case SignalingErrorCode.MEDIA_PERMISSION_DENIED:\n        return {\n          type: 'notify',\n          message: error.userMessage\n        };\n      \n      case SignalingErrorCode.RECORDING_FAILED:\n      case SignalingErrorCode.UPLOAD_FAILED:\n        return {\n          type: 'retry',\n          message: 'Retrying operation...',\n          delay: this.calculateDelay(attempts)\n        };\n      \n      default:\n        return {\n          type: 'notify',\n          message: error.userMessage\n        };\n    }\n  }\n\n  /**\n   * Execute recovery action\n   */\n  private async executeRecovery(\n    error: WebRTCError,\n    action: RecoveryAction,\n    recoveryCallback?: () => Promise<void>\n  ): Promise<RecoveryAction> {\n    const errorKey = this.getErrorKey(error);\n    const attempts = (this.retryAttempts.get(errorKey) || 0) + 1;\n    this.retryAttempts.set(errorKey, attempts);\n\n    this.emit('recovery-attempted', action, attempts);\n\n    if (action.type === 'retry' && recoveryCallback) {\n      try {\n        if (action.delay) {\n          await this.delay(action.delay);\n        }\n        \n        await recoveryCallback();\n        \n        // Reset retry count on success\n        this.retryAttempts.delete(errorKey);\n        this.emit('recovery-succeeded', action);\n        \n        return {\n          type: 'notify',\n          message: 'Connection restored successfully'\n        };\n      } catch (retryError) {\n        console.error('Recovery attempt failed:', retryError);\n        \n        if (attempts >= this.strategy.maxRetries) {\n          this.emit('recovery-failed', error, true);\n          return {\n            type: 'notify',\n            message: 'Unable to recover connection. Please refresh the page.'\n          };\n        } else {\n          this.emit('recovery-failed', error, false);\n          // Will retry on next error occurrence\n        }\n      }\n    }\n\n    return action;\n  }\n\n  /**\n   * Calculate exponential backoff delay\n   */\n  private calculateDelay(attempts: number): number {\n    const delay = this.strategy.baseDelay * Math.pow(this.strategy.backoffMultiplier, attempts);\n    return Math.min(delay, this.strategy.maxDelay);\n  }\n\n  /**\n   * Delay utility\n   */\n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Cleanup resources\n   */\n  cleanup(): void {\n    this.eventListeners.clear();\n    this.retryAttempts.clear();\n    this.lastErrors.clear();\n  }\n}"