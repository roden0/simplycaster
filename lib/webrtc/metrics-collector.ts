/**\n * WebRTC Metrics Collector\n * \n * Collects and tracks WebRTC connection metrics, signaling performance,\n * and participant connection statistics.\n */\n\n/**\n * Connection Metrics\n */\nexport interface ConnectionMetrics {\n  participantId: string;\n  roomId: string;\n  connectionEstablishmentTime: number; // Time to establish connection in ms\n  connectionState: RTCPeerConnectionState;\n  iceConnectionState: RTCIceConnectionState;\n  rtt: number; // Round trip time in ms\n  packetsLost: number;\n  packetsReceived: number;\n  bytesReceived: number;\n  bytesSent: number;\n  audioLevel?: number; // Audio level 0-1\n  videoFrameRate?: number;\n  videoBitrate?: number;\n  audioBitrate?: number;\n  timestamp: Date;\n}\n\n/**\n * Signaling Metrics\n */\nexport interface SignalingMetrics {\n  roomId: string;\n  messageType: string;\n  latency: number; // Message round-trip time in ms\n  success: boolean;\n  errorCode?: string;\n  participantCount: number;\n  timestamp: Date;\n}\n\n/**\n * Session Metrics\n */\nexport interface SessionMetrics {\n  roomId: string;\n  sessionId: string;\n  hostId: string;\n  participantCount: number;\n  maxParticipants: number;\n  sessionDuration: number; // Duration in ms\n  totalMessages: number;\n  connectionFailures: number;\n  reconnectionAttempts: number;\n  recordingDuration?: number;\n  createdAt: Date;\n  endedAt?: Date;\n}\n\n/**\n * Aggregated Metrics\n */\nexport interface AggregatedMetrics {\n  totalSessions: number;\n  totalParticipants: number;\n  averageSessionDuration: number;\n  averageParticipantsPerSession: number;\n  connectionSuccessRate: number;\n  averageConnectionTime: number;\n  averageSignalingLatency: number;\n  totalRecordingTime: number;\n  topErrorCodes: Array<{ code: string; count: number }>;\n  peakConcurrentSessions: number;\n  timestamp: Date;\n}\n\n/**\n * Metrics Collector Events\n */\nexport interface MetricsCollectorEvents {\n  'connection-established': (metrics: ConnectionMetrics) => void;\n  'connection-failed': (participantId: string, roomId: string, error: string) => void;\n  'signaling-message': (metrics: SignalingMetrics) => void;\n  'session-started': (metrics: SessionMetrics) => void;\n  'session-ended': (metrics: SessionMetrics) => void;\n  'metrics-aggregated': (metrics: AggregatedMetrics) => void;\n}\n\n/**\n * WebRTC Metrics Collector Class\n */\nexport class WebRTCMetricsCollector {\n  private connectionMetrics = new Map<string, ConnectionMetrics[]>();\n  private signalingMetrics: SignalingMetrics[] = [];\n  private sessionMetrics = new Map<string, SessionMetrics>();\n  private eventListeners = new Map<keyof MetricsCollectorEvents, Function[]>();\n  private aggregationTimer: number | null = null;\n  private readonly maxMetricsHistory = 1000;\n  private readonly aggregationInterval = 60000; // 1 minute\n\n  constructor() {\n    this.startAggregation();\n  }\n\n  /**\n   * Record connection establishment metrics\n   */\n  recordConnectionEstablished(\n    participantId: string,\n    roomId: string,\n    establishmentTime: number,\n    connectionState: RTCPeerConnectionState,\n    iceConnectionState: RTCIceConnectionState\n  ): void {\n    const metrics: ConnectionMetrics = {\n      participantId,\n      roomId,\n      connectionEstablishmentTime: establishmentTime,\n      connectionState,\n      iceConnectionState,\n      rtt: 0,\n      packetsLost: 0,\n      packetsReceived: 0,\n      bytesReceived: 0,\n      bytesSent: 0,\n      timestamp: new Date()\n    };\n\n    this.addConnectionMetrics(participantId, metrics);\n    this.emit('connection-established', metrics);\n    \n    console.log(`Connection established for ${participantId} in ${establishmentTime}ms`);\n  }\n\n  /**\n   * Record connection failure\n   */\n  recordConnectionFailure(\n    participantId: string,\n    roomId: string,\n    error: string\n  ): void {\n    this.emit('connection-failed', participantId, roomId, error);\n    console.log(`Connection failed for ${participantId}: ${error}`);\n  }\n\n  /**\n   * Update connection metrics from WebRTC stats\n   */\n  async updateConnectionMetrics(\n    participantId: string,\n    roomId: string,\n    peerConnection: RTCPeerConnection\n  ): Promise<void> {\n    try {\n      const stats = await peerConnection.getStats();\n      const metrics = this.parseWebRTCStats(participantId, roomId, stats);\n      \n      if (metrics) {\n        this.addConnectionMetrics(participantId, metrics);\n      }\n    } catch (error) {\n      console.error('Error updating connection metrics:', error);\n    }\n  }\n\n  /**\n   * Record signaling message metrics\n   */\n  recordSignalingMessage(\n    roomId: string,\n    messageType: string,\n    latency: number,\n    success: boolean,\n    participantCount: number,\n    errorCode?: string\n  ): void {\n    const metrics: SignalingMetrics = {\n      roomId,\n      messageType,\n      latency,\n      success,\n      errorCode,\n      participantCount,\n      timestamp: new Date()\n    };\n\n    this.signalingMetrics.push(metrics);\n    this.trimSignalingMetrics();\n    this.emit('signaling-message', metrics);\n  }\n\n  /**\n   * Start session tracking\n   */\n  startSession(\n    roomId: string,\n    sessionId: string,\n    hostId: string,\n    maxParticipants: number\n  ): void {\n    const metrics: SessionMetrics = {\n      roomId,\n      sessionId,\n      hostId,\n      participantCount: 1, // Host\n      maxParticipants,\n      sessionDuration: 0,\n      totalMessages: 0,\n      connectionFailures: 0,\n      reconnectionAttempts: 0,\n      createdAt: new Date()\n    };\n\n    this.sessionMetrics.set(sessionId, metrics);\n    this.emit('session-started', metrics);\n    \n    console.log(`Session started: ${sessionId} in room ${roomId}`);\n  }\n\n  /**\n   * Update session metrics\n   */\n  updateSession(\n    sessionId: string,\n    updates: Partial<Pick<SessionMetrics, \n      'participantCount' | 'totalMessages' | 'connectionFailures' | 'reconnectionAttempts' | 'recordingDuration'\n    >>\n  ): void {\n    const session = this.sessionMetrics.get(sessionId);\n    if (session) {\n      Object.assign(session, updates);\n      session.sessionDuration = Date.now() - session.createdAt.getTime();\n    }\n  }\n\n  /**\n   * End session tracking\n   */\n  endSession(sessionId: string): void {\n    const session = this.sessionMetrics.get(sessionId);\n    if (session) {\n      session.endedAt = new Date();\n      session.sessionDuration = session.endedAt.getTime() - session.createdAt.getTime();\n      \n      this.emit('session-ended', session);\n      console.log(`Session ended: ${sessionId}, duration: ${session.sessionDuration}ms`);\n    }\n  }\n\n  /**\n   * Get connection metrics for a participant\n   */\n  getConnectionMetrics(participantId: string): ConnectionMetrics[] {\n    return this.connectionMetrics.get(participantId) || [];\n  }\n\n  /**\n   * Get signaling metrics for a room\n   */\n  getSignalingMetrics(roomId?: string): SignalingMetrics[] {\n    if (roomId) {\n      return this.signalingMetrics.filter(m => m.roomId === roomId);\n    }\n    return [...this.signalingMetrics];\n  }\n\n  /**\n   * Get session metrics\n   */\n  getSessionMetrics(sessionId?: string): SessionMetrics | SessionMetrics[] {\n    if (sessionId) {\n      return this.sessionMetrics.get(sessionId) || null;\n    }\n    return Array.from(this.sessionMetrics.values());\n  }\n\n  /**\n   * Get aggregated metrics\n   */\n  getAggregatedMetrics(): AggregatedMetrics {\n    const sessions = Array.from(this.sessionMetrics.values());\n    const connections = Array.from(this.connectionMetrics.values()).flat();\n    const signaling = this.signalingMetrics;\n\n    const totalSessions = sessions.length;\n    const totalParticipants = sessions.reduce((sum, s) => sum + s.participantCount, 0);\n    const completedSessions = sessions.filter(s => s.endedAt);\n    \n    const averageSessionDuration = completedSessions.length > 0\n      ? completedSessions.reduce((sum, s) => sum + s.sessionDuration, 0) / completedSessions.length\n      : 0;\n    \n    const averageParticipantsPerSession = totalSessions > 0\n      ? totalParticipants / totalSessions\n      : 0;\n    \n    const successfulConnections = connections.filter(c => \n      c.connectionState === 'connected' || c.iceConnectionState === 'connected'\n    ).length;\n    \n    const connectionSuccessRate = connections.length > 0\n      ? successfulConnections / connections.length\n      : 0;\n    \n    const averageConnectionTime = connections.length > 0\n      ? connections.reduce((sum, c) => sum + c.connectionEstablishmentTime, 0) / connections.length\n      : 0;\n    \n    const successfulSignaling = signaling.filter(s => s.success);\n    const averageSignalingLatency = successfulSignaling.length > 0\n      ? successfulSignaling.reduce((sum, s) => sum + s.latency, 0) / successfulSignaling.length\n      : 0;\n    \n    const totalRecordingTime = sessions.reduce((sum, s) => sum + (s.recordingDuration || 0), 0);\n    \n    // Count error codes\n    const errorCounts = new Map<string, number>();\n    signaling.forEach(s => {\n      if (!s.success && s.errorCode) {\n        errorCounts.set(s.errorCode, (errorCounts.get(s.errorCode) || 0) + 1);\n      }\n    });\n    \n    const topErrorCodes = Array.from(errorCounts.entries())\n      .map(([code, count]) => ({ code, count }))\n      .sort((a, b) => b.count - a.count)\n      .slice(0, 5);\n    \n    // Calculate peak concurrent sessions (simplified)\n    const peakConcurrentSessions = Math.max(\n      ...sessions.map(s => s.participantCount),\n      0\n    );\n\n    return {\n      totalSessions,\n      totalParticipants,\n      averageSessionDuration,\n      averageParticipantsPerSession,\n      connectionSuccessRate,\n      averageConnectionTime,\n      averageSignalingLatency,\n      totalRecordingTime,\n      topErrorCodes,\n      peakConcurrentSessions,\n      timestamp: new Date()\n    };\n  }\n\n  /**\n   * Get metrics summary for a specific room\n   */\n  getRoomMetrics(roomId: string): {\n    sessions: SessionMetrics[];\n    connections: ConnectionMetrics[];\n    signaling: SignalingMetrics[];\n    summary: {\n      totalParticipants: number;\n      averageSessionDuration: number;\n      connectionSuccessRate: number;\n      signalingSuccessRate: number;\n    };\n  } {\n    const sessions = Array.from(this.sessionMetrics.values())\n      .filter(s => s.roomId === roomId);\n    \n    const connections = Array.from(this.connectionMetrics.values())\n      .flat()\n      .filter(c => c.roomId === roomId);\n    \n    const signaling = this.signalingMetrics.filter(s => s.roomId === roomId);\n    \n    const totalParticipants = sessions.reduce((sum, s) => sum + s.participantCount, 0);\n    \n    const completedSessions = sessions.filter(s => s.endedAt);\n    const averageSessionDuration = completedSessions.length > 0\n      ? completedSessions.reduce((sum, s) => sum + s.sessionDuration, 0) / completedSessions.length\n      : 0;\n    \n    const successfulConnections = connections.filter(c => \n      c.connectionState === 'connected' || c.iceConnectionState === 'connected'\n    ).length;\n    const connectionSuccessRate = connections.length > 0\n      ? successfulConnections / connections.length\n      : 0;\n    \n    const successfulSignaling = signaling.filter(s => s.success).length;\n    const signalingSuccessRate = signaling.length > 0\n      ? successfulSignaling / signaling.length\n      : 0;\n\n    return {\n      sessions,\n      connections,\n      signaling,\n      summary: {\n        totalParticipants,\n        averageSessionDuration,\n        connectionSuccessRate,\n        signalingSuccessRate\n      }\n    };\n  }\n\n  /**\n   * Clear old metrics to prevent memory leaks\n   */\n  clearOldMetrics(olderThanHours: number = 24): void {\n    const cutoffTime = Date.now() - (olderThanHours * 60 * 60 * 1000);\n    \n    // Clear old connection metrics\n    this.connectionMetrics.forEach((metrics, participantId) => {\n      const filtered = metrics.filter(m => m.timestamp.getTime() > cutoffTime);\n      if (filtered.length === 0) {\n        this.connectionMetrics.delete(participantId);\n      } else {\n        this.connectionMetrics.set(participantId, filtered);\n      }\n    });\n    \n    // Clear old signaling metrics\n    this.signalingMetrics = this.signalingMetrics.filter(\n      m => m.timestamp.getTime() > cutoffTime\n    );\n    \n    // Clear old completed sessions\n    const sessionsToDelete: string[] = [];\n    this.sessionMetrics.forEach((session, sessionId) => {\n      if (session.endedAt && session.endedAt.getTime() < cutoffTime) {\n        sessionsToDelete.push(sessionId);\n      }\n    });\n    \n    sessionsToDelete.forEach(sessionId => {\n      this.sessionMetrics.delete(sessionId);\n    });\n    \n    console.log(`Cleared metrics older than ${olderThanHours} hours`);\n  }\n\n  /**\n   * Add event listener\n   */\n  on<K extends keyof MetricsCollectorEvents>(event: K, listener: MetricsCollectorEvents[K]): void {\n    if (!this.eventListeners.has(event)) {\n      this.eventListeners.set(event, []);\n    }\n    this.eventListeners.get(event)!.push(listener);\n  }\n\n  /**\n   * Remove event listener\n   */\n  off<K extends keyof MetricsCollectorEvents>(event: K, listener: MetricsCollectorEvents[K]): void {\n    const listeners = this.eventListeners.get(event);\n    if (listeners) {\n      const index = listeners.indexOf(listener);\n      if (index > -1) {\n        listeners.splice(index, 1);\n      }\n    }\n  }\n\n  /**\n   * Emit event\n   */\n  private emit<K extends keyof MetricsCollectorEvents>(event: K, ...args: Parameters<MetricsCollectorEvents[K]>): void {\n    const listeners = this.eventListeners.get(event);\n    if (listeners) {\n      listeners.forEach(listener => {\n        try {\n          (listener as any)(...args);\n        } catch (error) {\n          console.error(`Error in metrics collector event listener for ${event}:`, error);\n        }\n      });\n    }\n  }\n\n  /**\n   * Add connection metrics for a participant\n   */\n  private addConnectionMetrics(participantId: string, metrics: ConnectionMetrics): void {\n    if (!this.connectionMetrics.has(participantId)) {\n      this.connectionMetrics.set(participantId, []);\n    }\n    \n    const participantMetrics = this.connectionMetrics.get(participantId)!;\n    participantMetrics.push(metrics);\n    \n    // Keep only recent metrics\n    if (participantMetrics.length > this.maxMetricsHistory) {\n      participantMetrics.splice(0, participantMetrics.length - this.maxMetricsHistory);\n    }\n  }\n\n  /**\n   * Parse WebRTC stats into our metrics format\n   */\n  private parseWebRTCStats(\n    participantId: string,\n    roomId: string,\n    stats: RTCStatsReport\n  ): ConnectionMetrics | null {\n    let rtt = 0;\n    let packetsLost = 0;\n    let packetsReceived = 0;\n    let bytesReceived = 0;\n    let bytesSent = 0;\n    let audioLevel: number | undefined;\n    let videoFrameRate: number | undefined;\n    let videoBitrate: number | undefined;\n    let audioBitrate: number | undefined;\n\n    for (const [id, stat] of stats.entries()) {\n      if (stat.type === 'candidate-pair' && stat.state === 'succeeded') {\n        rtt = (stat.currentRoundTripTime || 0) * 1000; // Convert to ms\n      } else if (stat.type === 'inbound-rtp') {\n        packetsLost += stat.packetsLost || 0;\n        packetsReceived += stat.packetsReceived || 0;\n        bytesReceived += stat.bytesReceived || 0;\n        \n        if (stat.kind === 'audio') {\n          audioLevel = stat.audioLevel;\n          audioBitrate = stat.bytesReceived ? (stat.bytesReceived * 8) / 1000 : undefined;\n        } else if (stat.kind === 'video') {\n          videoFrameRate = stat.framesPerSecond;\n          videoBitrate = stat.bytesReceived ? (stat.bytesReceived * 8) / 1000 : undefined;\n        }\n      } else if (stat.type === 'outbound-rtp') {\n        bytesSent += stat.bytesSent || 0;\n      }\n    }\n\n    // Only return metrics if we have meaningful data\n    if (packetsReceived === 0 && bytesSent === 0) {\n      return null;\n    }\n\n    return {\n      participantId,\n      roomId,\n      connectionEstablishmentTime: 0, // Not available from stats\n      connectionState: 'connected', // Assume connected if we have stats\n      iceConnectionState: 'connected',\n      rtt,\n      packetsLost,\n      packetsReceived,\n      bytesReceived,\n      bytesSent,\n      audioLevel,\n      videoFrameRate,\n      videoBitrate,\n      audioBitrate,\n      timestamp: new Date()\n    };\n  }\n\n  /**\n   * Trim signaling metrics to prevent memory leaks\n   */\n  private trimSignalingMetrics(): void {\n    if (this.signalingMetrics.length > this.maxMetricsHistory) {\n      this.signalingMetrics.splice(0, this.signalingMetrics.length - this.maxMetricsHistory);\n    }\n  }\n\n  /**\n   * Start periodic aggregation\n   */\n  private startAggregation(): void {\n    this.aggregationTimer = setInterval(() => {\n      const aggregated = this.getAggregatedMetrics();\n      this.emit('metrics-aggregated', aggregated);\n    }, this.aggregationInterval);\n  }\n\n  /**\n   * Cleanup resources\n   */\n  cleanup(): void {\n    if (this.aggregationTimer) {\n      clearInterval(this.aggregationTimer);\n      this.aggregationTimer = null;\n    }\n    \n    this.connectionMetrics.clear();\n    this.signalingMetrics.length = 0;\n    this.sessionMetrics.clear();\n    this.eventListeners.clear();\n    \n    console.log('WebRTC metrics collector cleaned up');\n  }\n}"