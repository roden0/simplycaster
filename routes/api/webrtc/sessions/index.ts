/**\n * WebRTC Sessions API\n * \n * GET /api/webrtc/sessions - Get all active WebRTC sessions\n */\n\nimport { Handlers } from \"$fresh/server.ts\";\nimport { getWebRTCServiceManager } from \"../../../../lib/webrtc/index.ts\";\nimport { authenticateRequest } from \"../../../../lib/middleware/auth.ts\";\n\nexport const handler: Handlers = {\n  async GET(req, ctx) {\n    try {\n      // Authenticate request (admin only)\n      const authResult = await authenticateRequest(req);\n      if (!authResult.success) {\n        return new Response(\n          JSON.stringify({ error: \"Authentication required\" }),\n          { \n            status: 401,\n            headers: { \"Content-Type\": \"application/json\" }\n          }\n        );\n      }\n\n      // Check if user is admin\n      if (authResult.user.role !== 'admin') {\n        return new Response(\n          JSON.stringify({ error: \"Admin access required\" }),\n          { \n            status: 403,\n            headers: { \"Content-Type\": \"application/json\" }\n          }\n        );\n      }\n\n      // Get WebRTC service manager\n      const serviceManager = getWebRTCServiceManager();\n      const roomCoordinator = serviceManager.getRoomCoordinator();\n\n      // Get all active sessions\n      const activeSessions = await roomCoordinator.getAllActiveSessions();\n\n      // Format session data\n      const sessions = activeSessions.map(session => ({\n        roomId: session.roomId,\n        sessionId: session.id,\n        hostId: session.hostId,\n        participantCount: session.participants.length,\n        connectedParticipants: session.participants.filter(p => p.isConnected).length,\n        isRecording: session.isRecording,\n        createdAt: session.createdAt,\n        lastActivity: session.lastActivity,\n        sessionDuration: Date.now() - session.createdAt.getTime(),\n        messageCount: session.messageCount || 0\n      }));\n\n      // Calculate summary statistics\n      const summary = {\n        totalSessions: sessions.length,\n        totalParticipants: sessions.reduce((sum, s) => sum + s.participantCount, 0),\n        totalConnectedParticipants: sessions.reduce((sum, s) => sum + s.connectedParticipants, 0),\n        activelRecordingSessions: sessions.filter(s => s.isRecording).length,\n        averageSessionDuration: sessions.length > 0 \n          ? sessions.reduce((sum, s) => sum + s.sessionDuration, 0) / sessions.length\n          : 0\n      };\n\n      const response = {\n        sessions,\n        summary,\n        timestamp: new Date().toISOString()\n      };\n\n      return new Response(\n        JSON.stringify(response),\n        { \n          status: 200,\n          headers: { \n            \"Content-Type\": \"application/json\",\n            \"Cache-Control\": \"no-cache, no-store, must-revalidate\"\n          }\n        }\n      );\n\n    } catch (error) {\n      console.error(\"Error getting WebRTC sessions:\", error);\n      return new Response(\n        JSON.stringify({ \n          error: \"Internal server error\",\n          message: error instanceof Error ? error.message : \"Unknown error\"\n        }),\n        { \n          status: 500,\n          headers: { \"Content-Type\": \"application/json\" }\n        }\n      );\n    }\n  }\n};"